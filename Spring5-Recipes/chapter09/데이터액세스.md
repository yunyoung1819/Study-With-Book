# :book: 스프링5 레시피

## :pushpin: Chapter09. 데이터 액세스

- 데이터 액세스는 거의 모든 엔터프라이즈 애플리케이션의 공통적인 기본 요건
- RDBMS에 저장된 데이터에 액세스하는 경우가 대부분
- 자바 SE의 핵심 요소인 JDBC(Java Database Connectivity, 자바 데이터베이스 연결)는
DB 제작사에 구애받지 않고 RDBMS에 액세스할 수 있도록 표준 API 세트를 제공함
    - JDBC 템플릿: 여러 유형의 DB 작업을 템플릿 메서드로 묶어 놓은 것
    - 스프링은 하이버네이트, JDO, 아이바티스, JPA (자바 퍼시스턴스 API) 등의 유명한 ORM 프레임워크를 대부분 지원함

> ORM 프레임워크는 (XML 또는 애너테이션 기반의) 매핑 메타데이터(클래스와 테이블 간 매핑, 프로퍼티와 컬럼 간 매핑 등)에 따라
> 객체를 저장하는 현대 기술

- 애플리케이션 DB 구성하기
- src/main/resource/META-INF/spring/config.properties

```
# [H2]
hibernate.connection.driver_class=org.h2.Driver
hibernate.connection.url=jdbc:h2:\database/cygnus;AUTO_SERVER=TRUE;CACHE_SIZE=131072;MVCC=TRUE
hibernate.connection.username=sa
hibernate.connection.password=
hibernate.dialect=org.hibernate.dialect.H2Dialect
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate

# [Oracle]
#hibernate.connection.driver_class=oracle.jdbc.driver.OracleDriver
#hibernate.connection.url=jdbc:oracle:thin:@127.0.0.1:1521:aiotion_db
#hibernate.connection.username=aiotion
#hibernate.connection.password=aiotion
#hibernate.dialect=org.hibernate.dialect.Oracle10gDialect
#org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.oracle.OracleDelegate

# [PostgreSQL]
#hibernate.connection.driver_class=org.postgresql.Driver
#hibernate.connection.url=jdbc:postgresql://127.0.0.1:5432/aiotion_db
#hibernate.connection.username=aiotion
#hibernate.connection.password=aiotion
#hibernate.dialect=com.nkia.cygnus.dialect.PostgreSQLDialect
#org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate

# [SQLServer]
#hibernate.connection.driver_class=com.microsoft.sqlserver.jdbc.SQLServerDriver
#hibernate.connection.url=jdbc:sqlserver://127.0.0.1:1433;databaseName=aiotion_db
#hibernate.connection.username=aiotion
#hibernate.connection.password=aiotion
#hibernate.dialect=com.nkia.cygnus.dialect.SQLServerUnicodeDialect
#org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.MSSQLDelegate

# [MySQL/MariaDB]
#hibernate.connection.driver_class=org.mariadb.jdbc.Driver
#hibernate.connection.url=jdbc:mariadb://127.0.0.1:3306/aiotion_db
#hibernate.connection.username=aiotion
#hibernate.connection.password=aiotion
#hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
#org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
```

- DAO 디자인 패턴
- 서로 다른 종류의 로직(표현 로직, 비즈니스 로직, 데이터 액세스 로직 등)을 하나의 거대한 모듈에 뒤섞는 설계 상의 실수를 저지르는 경우가 많다.
- DAO는 이런 문제를 해결하고자 데이터 액세스 로직을 표현하고, 비즈니스 로직과 분리하여 DAO라는 독립적인 모듈에 데이터 액세스 로직을 몽땅 담아 캡슐화한 패턴이다.

- ResourceDao.java
```
public interface ResourceDao extends GenericDao<Resource, Long> {

	public GroupResource getRootSystemGroupResource();
	
	public BusinessGroupResource getRootBusinessGroupResource();

	public List<Resource> findResourceByType(String resourceType);

	public List<Resource> findResourceByTypeWithPlatformIds(String resourceType, List<Long> platformResourceIds);

	public List<Resource> findResourceByTypeWithZoneId(String resourceType, String zoneId);

	public long countResourcesByType(String resourceType);
	public long countResourcesExcludeTypes(String[] excludeTypes);

	public List<Map<String, Object>> countResourcePerType(Long resourceId);
	...
}
```

- ResourceDaoImpl.java

```
@SuppressWarnings("unchecked")
@Repository
public class ResourceDaoImpl extends HibernateGenericDao<Resource, Long> implements ResourceDao {

	public GroupResource getRootSystemGroupResource() {
		Criteria crit = getSession().createCriteria(GroupResource.class)
				.add(Restrictions.isNull("parentResource"))
				.add(Restrictions.eq("system", true));

		return (GroupResource)crit.uniqueResult();
	}
	
	public BusinessGroupResource getRootBusinessGroupResource() {
		Criteria crit = getSession().createCriteria(BusinessGroupResource.class)
				.add(Restrictions.isNull("parentResource"))
				.add(Restrictions.eq("system", true));

		return (BusinessGroupResource) crit.uniqueResult();
	}

	@Override
	protected Session getSession() {
		Session session = sessionFactory.getCurrentSession();
		session.enableFilter("deletedFilter");
		session.disableFilter("aclFilter");
		return session;
	}

	public List<Resource> findResourceByType(String resourceType) {
		return getSession().createQuery("from Resource"
				+ " where resourceTypeName = :resourceType")
				.setParameter("resourceType", resourceType)
				.list();
	}

	public List<Resource> findResourceByTypeWithPlatformIds(String resourceType, List<Long> platformResourceIds) {
		return getSession().createQuery("from Resource"
				+ " where resourceTypeName = :resourceType"
				+ " and platformResourceId in :platformResourceIds")
				.setParameter("resourceType", resourceType)
				.setParameterList("platformResourceIds", platformResourceIds)
				.list();
	}
    ...
}
```

- JDBC에 특정한 SQLException을 던지는 건 취지에 어긋나므로 보통 DAO 인터페이스 구현체에서는 RuntimeException의 하위 예외로 감싼다.

- JDBC로 DAO 구현하기
- JDBC를 사용해 DB 데이터에 액세스하려면 DAO 구현클래스가 필요하고 DB에 SQL 문을 실행하려면 드라이버 클래스명, DB URL, 유저명, 패스워드를 지정해서 DB에 접속해야함
- 하지만 미리 구성된 javax.sql.DataSource 객체를 이용하면 접속 정보를 자세히 몰라도 DB에 접속할 수 있음

- CygnusCoreConfig.java
```
@Bean(name = "dataSource", destroyMethod="close")
	public DataSource dataSource() {
		DataSource dataSource = new DataSource(buildDataSourceProperties());
		log.info("DB Connection pool properties: {}", dataSource.getPoolProperties());
		return dataSource;
	}
	
private PoolProperties buildDataSourceProperties() {
		PoolProperties dataSourceProperties = new PoolProperties();
		dataSourceProperties.setDriverClassName(driverClassName);
		dataSourceProperties.setUrl(url);
		dataSourceProperties.setUsername(username);
		if(password != null) {
			if (password.startsWith(ACipher.PREFIX) && password.length() > 24) {
				password = ACipher.decrypt(ACipher.DBCP_SEED_KEY, password);
				dataSourceProperties.setPassword(password);
			} else {
				dataSourceProperties.setPassword(password);
				changePasswordConfiguration(password);
			}
		}
		dataSourceProperties.setInitialSize(initialSize);
		dataSourceProperties.setMaxActive(maxActive);
		dataSourceProperties.setMaxIdle(maxIdle);
		dataSourceProperties.setMinIdle(minIdle);
		dataSourceProperties.setMaxWait(maxWait);
		
		dataSourceProperties.setTestWhileIdle(testWhileIdle);
		dataSourceProperties.setTestOnBorrow(testOnBorrow);
		dataSourceProperties.setValidationQuery(detectValidationQuery());
		dataSourceProperties.setValidationQueryTimeout(validationQueryTimeout);
		dataSourceProperties.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
		dataSourceProperties.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
		dataSourceProperties.setLogAbandoned(logAbandoned);
		dataSourceProperties.setRemoveAbandoned(removeAbandoned);
		dataSourceProperties.setRemoveAbandonedTimeout(removeAbandonedTimeout);
		dataSourceProperties.setConnectionProperties(connectionProperties);
		dataSourceProperties.setDefaultAutoCommit(defaultAutoCommit);
		if(jdbcInterceptors != null && !jdbcInterceptors.isEmpty()) {
			dataSourceProperties.setJdbcInterceptors(jdbcInterceptors);
		}
		return dataSourceProperties;
	}
```

- 스프링 데이터 소스 구성하기
- 데이터 소스 인터페이스는 여러 가지 구현체가 있음
- 그 중 HikariCP (히카리CP)와 아파치 커먼스 (DBCP)가 가장 잘 알려진 오픈소스 구현체이다.
- 자바 애플리케이션 프레임워크을 대표하는 스프링 역시 간편하면서도 기능은 막강한 데이터 소스 구현체를 자랑합니다.
- 그중 요청을 할 때마다 접속을 새로 여는 DriverManagerDataSource는 가장 간단한 구현체 입니다.

### :seedling: 레시피 9-1. JDBC 템플릿으로 DB 수정하기

- JDBC를 직접 사용하면 지루하고 장황한 API 호출이 반복되며 그때마다 큰 의미가 없는 과정이 되풀이됩니다.

1. 데이터소스에서 DB 접속을 얻는다.
2. PreparedStatement 객체를 생성한다.
3. 매개변수를 PreparedStatement 객체에 바인딩한다.
4. PreparedStatement를 실행한다.
5. SQL Exception을 처리한다.
6. 구문 및 접속 객체를 삭제한다. 